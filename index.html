<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }
        
        .game-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
        }
        
        h1 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 2em;
        }
        
        .info {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 15px;
        }
        
        canvas {
            border: 3px solid #333;
            background: #000;
            display: block;
            margin: 0 auto;
        }
        
        .controls {
            margin-top: 15px;
            color: #666;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üêç Snake Game</h1>
        <div class="info" id="info">Use arrow keys to navigate</div>
        <canvas id="gameCanvas" width="510" height="560"></canvas>
        <div class="controls" id="controls">
            Selection: LEFT/RIGHT arrows, SPACE to start
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const infoElement = document.getElementById('info');
        const controlsElement = document.getElementById('controls');
        
        // Game settings
        const GRID_SIZE = 17;
        const CELL_SIZE = 30;
        const WIDTH = GRID_SIZE * CELL_SIZE;
        const HEIGHT = GRID_SIZE * CELL_SIZE + 50;
        
        // Colors
        const COLORS = {
            BLACK: '#000000',
            WHITE: '#FFFFFF',
            RED: '#FF0000',
            GRAY: '#323232',
            PURPLE: '#800080',
            YELLOW: '#FFFF00',
            BLUE: '#0000FF',
            LIGHT_GREEN: '#90EE90'
        };
        
        // Snake color schemes
        const SNAKE_COLORS = [
            { name: "Classic Green", head: '#00FF00', body: '#00C800' },
            { name: "Ocean Blue", head: '#0096FF', body: '#0064C8' },
            { name: "Fire Red", head: '#FF3232', body: '#C80000' },
            { name: "Royal Purple", head: '#B400FF', body: '#7800B4' },
            { name: "Sunset Orange", head: '#FFA500', body: '#C86400' },
            { name: "Bubblegum Pink", head: '#FFC0CB', body: '#FF6496' },
            { name: "Cyber Cyan", head: '#00FFFF', body: '#00B4B4' },
            { name: "Golden", head: '#FFD700', body: '#DAA520' }
        ];
        
        // Power-up types
        const POWERUP = {
            FOOD: 'FOOD',
            SPEED_UP: 'SPEED_UP',
            TELEPORT: 'TELEPORT',
            SLOW_DOWN: 'SLOW_DOWN',
            DOUBLE_GROWTH: 'DOUBLE_GROWTH'
        };
        
        // Game state
        let inSelectionScreen = true;
        let selectedColorIndex = 0;
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = {};
        let currentPowerup = POWERUP.FOOD;
        let score = 0;
        let gameOver = false;
        let baseSpeed = 10;
        let currentSpeed = baseSpeed;
        let speedBoostEndTime = 0;
        let lastUpdateTime = 0;
        
        // Music
        let bgMusic = null;
        let musicLoaded = false;
        try {
            bgMusic = new Audio('background_music.mp3');
            bgMusic.loop = true;
            musicLoaded = true;
        } catch (e) {
            console.log('Music file not found');
        }
        
        function startGame() {
            const startX = Math.floor(GRID_SIZE / 2);
            const startY = Math.floor(GRID_SIZE / 2);
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            gameOver = false;
            currentSpeed = baseSpeed;
            speedBoostEndTime = 0;
            currentPowerup = POWERUP.FOOD;
            spawnFood();
            inSelectionScreen = false;
            lastUpdateTime = Date.now();
            
            if (bgMusic && musicLoaded) {
                bgMusic.play().catch(() => {});
                bgMusic.volume = 0.5;
            }
            
            controlsElement.textContent = 'Arrow keys to move, M to toggle music';
        }
        
        function spawnFood() {
            while (true) {
                food = {
                    x: Math.floor(Math.random() * GRID_SIZE),
                    y: Math.floor(Math.random() * GRID_SIZE)
                };
                
                let onSnake = false;
                for (let segment of snake) {
                    if (segment.x === food.x && segment.y === food.y) {
                        onSnake = true;
                        break;
                    }
                }
                
                if (!onSnake) break;
            }
        }
        
        function spawnNewPowerup() {
            const rand = Math.random();
            if (rand < 0.3) {
                currentPowerup = POWERUP.FOOD;
            } else {
                const powerups = [POWERUP.SPEED_UP, POWERUP.TELEPORT, POWERUP.SLOW_DOWN, POWERUP.DOUBLE_GROWTH];
                currentPowerup = powerups[Math.floor(Math.random() * powerups.length)];
            }
            spawnFood();
        }
        
        function getPowerupColor() {
            switch (currentPowerup) {
                case POWERUP.FOOD: return COLORS.RED;
                case POWERUP.SPEED_UP: return COLORS.PURPLE;
                case POWERUP.TELEPORT: return COLORS.LIGHT_GREEN;
                case POWERUP.SLOW_DOWN: return COLORS.YELLOW;
                case POWERUP.DOUBLE_GROWTH: return COLORS.BLUE;
                default: return COLORS.RED;
            }
        }
        
        function update() {
            if (gameOver || inSelectionScreen) return;
            
            const now = Date.now() / 1000;
            if (speedBoostEndTime > 0 && now >= speedBoostEndTime) {
                currentSpeed = baseSpeed;
                speedBoostEndTime = 0;
            }
            
            direction = nextDirection;
            
            const head = { 
                x: snake[0].x + direction.x, 
                y: snake[0].y + direction.y 
            };
            
            // Check boundaries
            if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                gameOver = true;
                if (bgMusic && musicLoaded) bgMusic.pause();
                infoElement.textContent = 'Game Over! Score: ' + score;
                controlsElement.textContent = 'Press SPACE to restart';
                return;
            }
            
            // Check self collision
            for (let segment of snake) {
                if (segment.x === head.x && segment.y === head.y) {
                    gameOver = true;
                    if (bgMusic && musicLoaded) bgMusic.pause();
                    infoElement.textContent = 'Game Over! Score: ' + score;
                    controlsElement.textContent = 'Press SPACE to restart';
                    return;
                }
            }
            
            snake.unshift(head);
            
            // Check food
            if (head.x === food.x && head.y === food.y) {
                score++;
                
                const currentTime = Date.now() / 1000;
                
                if (currentPowerup === POWERUP.SPEED_UP) {
                    currentSpeed = baseSpeed + 2;
                    speedBoostEndTime = currentTime + 5;
                } else if (currentPowerup === POWERUP.SLOW_DOWN) {
                    currentSpeed = Math.max(5, baseSpeed - 2);
                    speedBoostEndTime = currentTime + 5;
                } else if (currentPowerup === POWERUP.TELEPORT) {
                    const newPos = { x: Math.floor(Math.random() * GRID_SIZE), y: Math.floor(Math.random() * GRID_SIZE) };
                    snake[0] = newPos;
                } else if (currentPowerup === POWERUP.DOUBLE_GROWTH) {
                    if (snake.length > 1) {
                        const tail = snake[snake.length - 1];
                        snake.push({ x: tail.x, y: tail.y });
                    }
                }
                
                spawnNewPowerup();
            } else {
                snake.pop();
            }
        }
        
        function drawSelectionScreen() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            ctx.fillStyle = COLORS.WHITE;
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SELECT YOUR SNAKE', WIDTH / 2, 60);
            
            ctx.font = '18px Arial';
            ctx.fillStyle = COLORS.GRAY;
            ctx.fillText('Use LEFT/RIGHT arrows to choose', WIDTH / 2, 100);
            ctx.fillText('Press SPACE to start', WIDTH / 2, 130);
            
            // Draw snake previews in a grid
            const startY = 180;
            const boxSize = 40;
            const spacing = 60;
            
            SNAKE_COLORS.forEach((colorScheme, i) => {
                const col = i % 4;
                const row = Math.floor(i / 4);
                const xPos = WIDTH / 2 - 200 + col * 120;
                const yPos = startY + row * spacing;
                
                // Draw snake preview
                for (let j = 0; j < 3; j++) {
                    ctx.fillStyle = j === 0 ? colorScheme.head : colorScheme.body;
                    ctx.fillRect(xPos + j * 15, yPos, 12, boxSize);
                }
                
                // Highlight selected
                if (i === selectedColorIndex) {
                    ctx.strokeStyle = COLORS.WHITE;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(xPos - 5, yPos - 5, 50, boxSize + 10);
                }
                
                // Name
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(colorScheme.name, xPos - 10, yPos + boxSize + 15);
            });
            
            // Selected info
            ctx.fillStyle = COLORS.WHITE;
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Selected: ' + SNAKE_COLORS[selectedColorIndex].name, WIDTH / 2, HEIGHT - 60);
        }
        
        function drawGame() {
            ctx.fillStyle = COLORS.BLACK;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // Grid
            ctx.strokeStyle = COLORS.GRAY;
            ctx.lineWidth = 1;
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
            
            // Snake
            const colorScheme = SNAKE_COLORS[selectedColorIndex];
            snake.forEach((seg, i) => {
                ctx.fillStyle = i === 0 ? colorScheme.head : colorScheme.body;
                ctx.fillRect(seg.x * CELL_SIZE, seg.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            });
            
            // Food
            ctx.fillStyle = getPowerupColor();
            ctx.fillRect(food.x * CELL_SIZE, food.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            
            // Score
            ctx.fillStyle = COLORS.WHITE;
            ctx.font = '20px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Score: ' + score, 10, HEIGHT - 20);
            
            // Speed indicator
            if (speedBoostEndTime > 0) {
                const msg = currentSpeed > baseSpeed ? 'SPEED BOOST!' : 'SLOWED DOWN!';
                const color = currentSpeed > baseSpeed ? COLORS.PURPLE : COLORS.YELLOW;
                ctx.fillStyle = color;
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(msg, WIDTH / 2, 25);
            }
            
            // Music status
            if (musicLoaded) {
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = '14px Arial';
                ctx.textAlign = 'right';
                const text = bgMusic && !bgMusic.paused ? 'Music: ON (M)' : 'Music: OFF (M)';
                ctx.fillText(text, WIDTH - 10, HEIGHT - 20);
            }
            
            // Game over
            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                
                ctx.fillStyle = COLORS.RED;
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER!', WIDTH / 2, HEIGHT / 2 - 20);
                
                ctx.fillStyle = COLORS.WHITE;
                ctx.font = '24px Arial';
                ctx.fillText('Final Score: ' + score, WIDTH / 2, HEIGHT / 2 + 20);
                ctx.font = '18px Arial';
                ctx.fillText('Press SPACE to restart', WIDTH / 2, HEIGHT / 2 + 50);
            }
        }
        
        function draw() {
            if (inSelectionScreen) {
                drawSelectionScreen();
            } else {
                drawGame();
            }
        }
        
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastUpdateTime;
            const updateInterval = 1000 / currentSpeed;
            
            if (!inSelectionScreen && !gameOver && deltaTime >= updateInterval) {
                update();
                lastUpdateTime = now;
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            if (inSelectionScreen) {
                if (e.key === 'ArrowLeft') {
                    selectedColorIndex = (selectedColorIndex - 1 + SNAKE_COLORS.length) % SNAKE_COLORS.length;
                } else if (e.key === 'ArrowRight') {
                    selectedColorIndex = (selectedColorIndex + 1) % SNAKE_COLORS.length;
                } else if (e.key === ' ') {
                    e.preventDefault();
                    startGame();
                }
            } else {
                if (e.key === 'ArrowUp' && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                } else if (e.key === 'ArrowDown' && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (e.key === 'ArrowLeft' && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                } else if (e.key === 'ArrowRight' && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (e.key === 'm' || e.key === 'M') {
                    if (bgMusic && musicLoaded) {
                        if (bgMusic.paused) {
                            bgMusic.play().catch(() => {});
                        } else {
                            bgMusic.pause();
                        }
                    }
                } else if (e.key === ' ' && gameOver) {
                    e.preventDefault();
                    inSelectionScreen = true;
                    selectedColorIndex = 0;
                    infoElement.textContent = 'Use arrow keys to navigate';
                    controlsElement.textContent = 'Selection: LEFT/RIGHT arrows, SPACE to start';
                }
            }
        });
        
        // Start game loop
        gameLoop();
    </script>
</body>
</html>
