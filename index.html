<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake Game</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
    }
    #game-container {
      display: flex;
      gap: 30px;
      align-items: flex-start;
    }
    #canvas-section {
      text-align: center;
    }
    canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #444;
      background: #000;
    }
    #info {
      margin-top: 12px;
      font-size: 14px;
      color: #ccc;
      line-height: 1.5;
    }
    #legend {
      background: #111;
      border: 2px solid #444;
      border-radius: 8px;
      padding: 20px;
      width: 250px;
    }
    #legend h2 {
      margin: 0 0 15px 0;
      font-size: 20px;
      color: #fff;
      border-bottom: 2px solid #444;
      padding-bottom: 10px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      font-size: 14px;
    }
    .legend-color {
      width: 24px;
      height: 24px;
      margin-right: 12px;
      border: 1px solid #666;
      flex-shrink: 0;
    }
    .legend-text {
      line-height: 1.3;
    }
    .legend-title {
      font-weight: bold;
      color: #fff;
    }
    .legend-desc {
      color: #aaa;
      font-size: 12px;
    }
    .section-divider {
      border-top: 1px solid #333;
      margin: 15px 0;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="canvas-section">
      <canvas id="game" width="510" height="560"></canvas>
      <div id="info">
        <div>Selection: LEFT/RIGHT = color, UP/DOWN = difficulty, SPACE = start</div>
        <div>In game: Arrow keys to move, M = toggle music, SPACE after Game Over = restart</div>
      </div>
    </div>
    
    <div id="legend">
      <h2>Power-Ups</h2>
      
      <div class="legend-item">
        <div class="legend-color" style="background: #FF0000;"></div>
        <div class="legend-text">
          <div class="legend-title">Red - Food</div>
          <div class="legend-desc">Grow by 1 segment</div>
        </div>
      </div>
      
      <div class="legend-item">
        <div class="legend-color" style="background: #800080;"></div>
        <div class="legend-text">
          <div class="legend-title">Purple - Speed Up</div>
          <div class="legend-desc">+0.2 speed for 5 sec</div>
        </div>
      </div>
      
      <div class="legend-item">
        <div class="legend-color" style="background: #90EE90;"></div>
        <div class="legend-text">
          <div class="legend-title">Green - Teleport</div>
          <div class="legend-desc">Random teleport</div>
        </div>
      </div>
      
      <div class="legend-item">
        <div class="legend-color" style="background: #FFFF00;"></div>
        <div class="legend-text">
          <div class="legend-title">Yellow - Slow Down</div>
          <div class="legend-desc">-0.2 speed for 5 sec</div>
        </div>
      </div>
      
      <div class="legend-item">
        <div class="legend-color" style="background: #0000FF;"></div>
        <div class="legend-text">
          <div class="legend-title">Blue - Double Growth</div>
          <div class="legend-desc">Grow by 2 segments</div>
        </div>
      </div>
      
      <div class="section-divider"></div>
      
      <h2 style="margin-top: 15px;">Difficulty Modes</h2>
      
      <div style="font-size: 13px; line-height: 1.6; color: #ccc;">
        <div style="margin-bottom: 10px;">
          <strong style="color: #90EE90;">Easy:</strong> Only red food
        </div>
        <div style="margin-bottom: 10px;">
          <strong style="color: #FFFF00;">Medium:</strong> All except green
        </div>
        <div style="margin-bottom: 10px;">
          <strong style="color: #FF6666;">Hard:</strong> All power-ups
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==== CONFIGURATION ====
    const GRID_SIZE = 17;
    const CELL_SIZE = 30;
    const WIDTH = GRID_SIZE * CELL_SIZE;
    const HEIGHT = GRID_SIZE * CELL_SIZE + 50;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const Direction = {
      UP:    { x:  0, y: -1 },
      DOWN:  { x:  0, y:  1 },
      LEFT:  { x: -1, y:  0 },
      RIGHT: { x:  1, y:  0 }
    };

    const POWERUP_TYPES = {
      FOOD: "FOOD",
      SPEED_UP: "SPEED_UP",
      TELEPORT: "TELEPORT",
      SLOW_DOWN: "SLOW_DOWN",
      DOUBLE_GROWTH: "DOUBLE_GROWTH"
    };

    // Difficulty modes
    const DIFFICULTIES = [
      {
        name: "Easy",
        description: "Only red food",
        id: "EASY",
        color: [144, 238, 144]
      },
      {
        name: "Medium",
        description: "All except green",
        id: "MEDIUM",
        color: [255, 255, 0]
      },
      {
        name: "Hard",
        description: "All power-ups",
        id: "HARD",
        color: [255, 102, 102]
      }
    ];

    // Snake color schemes
    const SNAKE_COLORS = [
      { name: "Classic Green", head: [0, 255, 0], body: [0, 200, 0] },
      { name: "Ocean Blue",   head: [0, 150, 255], body: [0, 100, 200] },
      { name: "Fire Red",     head: [255, 50, 50], body: [200, 0, 0] },
      { name: "Royal Purple", head: [180, 0, 255], body: [120, 0, 180] },
      { name: "Sunset Orange",head: [255, 165, 0], body: [200, 100, 0] },
      { name: "Bubblegum Pink", head: [255, 192, 203], body: [255, 100, 150] },
      { name: "Cyber Cyan",   head: [0, 255, 255], body: [0, 180, 180] },
      { name: "Golden",       head: [255, 215, 0], body: [218, 165, 32] }
    ];

    const COLORS = {
      BLACK: [0, 0, 0],
      WHITE: [255, 255, 255],
      RED: [255, 0, 0],
      GRAY: [50, 50, 50],
      PURPLE: [128, 0, 128],
      YELLOW: [255, 255, 0],
      BLUE: [0, 0, 255],
      LIGHT_GREEN: [144, 238, 144]
    };

    function rgb(arr) {
      return `rgb(${arr[0]}, ${arr[1]}, ${arr[2]})`;
    }

    // ==== GAME STATE ====
    let inSelectionScreen = true;
    let selectedColorIndex = 0;
    let selectedDifficultyIndex = 1; // Start with Medium

    let snake = [];
    let direction = Direction.RIGHT;
    let nextDirection = Direction.RIGHT;

    let currentPowerup = POWERUP_TYPES.FOOD;
    let powerupPos = null;

    let score = 0;
    const baseSpeed = 10;
    let currentSpeed = baseSpeed;
    let speedBoostEndTime = 0;

    let gameOver = false;
    let lastStepTime = 0;
    
    // Countdown state
    let inCountdown = false;
    let countdownNumber = 3;
    let countdownStartTime = 0;
    let countdownScale = 1;

    // Music
    let bgMusic = null;
    let musicLoaded = false;
    let userInteracted = false;
    try {
      bgMusic = new Audio("background_music.mp3");
      bgMusic.loop = true;
      musicLoaded = true;
    } catch (e) {
      musicLoaded = false;
    }

    function toggleMusic() {
      if (!bgMusic || !musicLoaded) return;
      if (bgMusic.paused) {
        bgMusic.play().catch(() => {});
      } else {
        bgMusic.pause();
      }
    }

    // ==== HELPERS ====
    function randomEmptyCell() {
      while (true) {
        const x = Math.floor(Math.random() * GRID_SIZE);
        const y = Math.floor(Math.random() * GRID_SIZE);
        if (!snake.some(seg => seg.x === x && seg.y === y)) {
          return { x, y };
        }
      }
    }

    function spawnItem() {
      powerupPos = randomEmptyCell();
    }

    function spawnNewPowerup() {
      const difficultyId = DIFFICULTIES[selectedDifficultyIndex].id;
      let possible = [];

      if (difficultyId === "EASY") {
        // Only red food
        currentPowerup = POWERUP_TYPES.FOOD;
        spawnItem();
        return;
      } else if (difficultyId === "MEDIUM") {
        // All except green (TELEPORT)
        possible = [
          POWERUP_TYPES.FOOD,
          POWERUP_TYPES.SPEED_UP,
          POWERUP_TYPES.SLOW_DOWN,
          POWERUP_TYPES.DOUBLE_GROWTH
        ];
      } else {
        // HARD: all power-ups including green (TELEPORT)
        possible = [
          POWERUP_TYPES.FOOD,
          POWERUP_TYPES.SPEED_UP,
          POWERUP_TYPES.TELEPORT,
          POWERUP_TYPES.SLOW_DOWN,
          POWERUP_TYPES.DOUBLE_GROWTH
        ];
      }

      currentPowerup = possible[Math.floor(Math.random() * possible.length)];
      spawnItem();
    }

    function getPowerupColor() {
      if (currentPowerup === POWERUP_TYPES.FOOD) return rgb(COLORS.RED);
      if (currentPowerup === POWERUP_TYPES.SPEED_UP) return rgb(COLORS.PURPLE);
      if (currentPowerup === POWERUP_TYPES.TELEPORT) return rgb(COLORS.LIGHT_GREEN);
      if (currentPowerup === POWERUP_TYPES.SLOW_DOWN) return rgb(COLORS.YELLOW);
      if (currentPowerup === POWERUP_TYPES.DOUBLE_GROWTH) return rgb(COLORS.BLUE);
      return rgb(COLORS.RED);
    }

    // ==== GAME SETUP ====
    function startCountdown() {
      inSelectionScreen = false;
      inCountdown = true;
      countdownNumber = 3;
      countdownStartTime = performance.now();
      countdownScale = 1;
    }
    
    function startGame() {
      const startX = Math.floor(GRID_SIZE / 2);
      const startY = Math.floor(GRID_SIZE / 2);
      snake = [
        { x: startX, y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];

      direction = Direction.RIGHT;
      nextDirection = Direction.RIGHT;
      score = 0;
      gameOver = false;
      currentSpeed = baseSpeed;
      speedBoostEndTime = 0;

      currentPowerup = POWERUP_TYPES.FOOD;
      spawnItem();

      inCountdown = false;
      lastStepTime = performance.now();

      if (bgMusic && musicLoaded && userInteracted) {
        bgMusic.play().catch(() => {});
        bgMusic.volume = 0.5;
      }
    }

    function resetToSelectionScreen() {
      inSelectionScreen = true;
      gameOver = false;
      if (bgMusic && musicLoaded) {
        bgMusic.pause();
      }
    }

    // ==== INPUT ====
    document.addEventListener("keydown", (e) => {
      userInteracted = true;

      // Selection screen controls
      if (inSelectionScreen) {
        if (e.key === "ArrowLeft") {
          selectedColorIndex =
            (selectedColorIndex - 1 + SNAKE_COLORS.length) % SNAKE_COLORS.length;
        } else if (e.key === "ArrowRight") {
          selectedColorIndex =
            (selectedColorIndex + 1) % SNAKE_COLORS.length;
        } else if (e.key === "ArrowUp") {
          selectedDifficultyIndex =
            (selectedDifficultyIndex - 1 + DIFFICULTIES.length) % DIFFICULTIES.length;
        } else if (e.key === "ArrowDown") {
          selectedDifficultyIndex =
            (selectedDifficultyIndex + 1) % DIFFICULTIES.length;
        } else if (e.key === " " || e.code === "Space") {
          e.preventDefault();
          startCountdown();
        }
        return;
      }

      // In-game controls
      if (e.key === "ArrowUp") {
        if (direction !== Direction.DOWN) nextDirection = Direction.UP;
      } else if (e.key === "ArrowDown") {
        if (direction !== Direction.UP) nextDirection = Direction.DOWN;
      } else if (e.key === "ArrowLeft") {
        if (direction !== Direction.RIGHT) nextDirection = Direction.LEFT;
      } else if (e.key === "ArrowRight") {
        if (direction !== Direction.LEFT) nextDirection = Direction.RIGHT;
      } else if (e.key === "m" || e.key === "M") {
        toggleMusic();
      } else if ((e.key === " " || e.code === "Space") && gameOver) {
        e.preventDefault();
        resetToSelectionScreen();
      }
    });

    // ==== UPDATE ====
    function updateCountdown(timestamp) {
      const elapsed = timestamp - countdownStartTime;
      const numberDuration = 1000; // Each number lasts 1 second
      
      // Calculate which number we're on
      const numberIndex = Math.floor(elapsed / numberDuration);
      
      if (numberIndex >= 3) {
        // Countdown finished, start game
        startGame();
        return;
      }
      
      countdownNumber = 3 - numberIndex;
      
      // Calculate scale (shrink from 3.0 to 1.0 over 1 second)
      const progress = (elapsed % numberDuration) / numberDuration;
      countdownScale = 3.0 - (progress * 2.0); // Goes from 3.0 to 1.0
    }
    
    function updateGame() {
      if (gameOver || inSelectionScreen || inCountdown) return;

      const nowSec = performance.now() / 1000;
      if (speedBoostEndTime > 0 && nowSec >= speedBoostEndTime) {
        currentSpeed = baseSpeed;
        speedBoostEndTime = 0;
      }

      direction = nextDirection;

      const head = snake[0];
      const newHead = {
        x: head.x + direction.x,
        y: head.y + direction.y
      };

      // Walls
      if (
        newHead.x < 0 || newHead.x >= GRID_SIZE ||
        newHead.y < 0 || newHead.y >= GRID_SIZE
      ) {
        gameOver = true;
        if (bgMusic && musicLoaded) bgMusic.pause();
        return;
      }

      // Self collision
      if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        gameOver = true;
        if (bgMusic && musicLoaded) bgMusic.pause();
        return;
      }

      snake.unshift(newHead);

      // Eat powerup?
      if (powerupPos && newHead.x === powerupPos.x && newHead.y === powerupPos.y) {
        score += 1;

        if (currentPowerup === POWERUP_TYPES.FOOD) {
          // just grow
        } else if (currentPowerup === POWERUP_TYPES.SPEED_UP) {
          currentSpeed = baseSpeed + 2;
          speedBoostEndTime = nowSec + 5;
        } else if (currentPowerup === POWERUP_TYPES.SLOW_DOWN) {
          currentSpeed = Math.max(5, baseSpeed - 2);
          speedBoostEndTime = nowSec + 5;
        } else if (currentPowerup === POWERUP_TYPES.TELEPORT) {
          const newPos = randomEmptyCell();
          snake[0] = newPos;
        } else if (currentPowerup === POWERUP_TYPES.DOUBLE_GROWTH) {
          if (snake.length > 1) {
            const tail = snake[snake.length - 1];
            snake.push({ x: tail.x, y: tail.y });
          }
        }

        spawnNewPowerup();
      } else {
        snake.pop();
      }
    }

    // ==== DRAW ====
    function clearCanvas() {
      ctx.fillStyle = rgb(COLORS.BLACK);
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }
    
    function drawCountdown() {
      clearCanvas();
      
      // Draw the grid faintly in background
      ctx.strokeStyle = rgb(COLORS.GRAY);
      ctx.lineWidth = 1;
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
      
      // Draw countdown number with scaling effect
      ctx.save();
      ctx.translate(WIDTH / 2, (HEIGHT - 50) / 2);
      ctx.scale(countdownScale, countdownScale);
      
      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.font = "bold 120px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(countdownNumber, 0, 0);
      
      ctx.restore();
    }

    function drawSelectionScreen() {
      clearCanvas();

      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.font = "bold 36px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("SELECT YOUR SNAKE", WIDTH / 2, 70);

      ctx.font = "16px sans-serif";
      ctx.fillStyle = rgb(COLORS.GRAY);
      ctx.fillText("Use LEFT/RIGHT arrows to choose color", WIDTH / 2, 105);
      ctx.fillText("Use UP/DOWN arrows to choose difficulty", WIDTH / 2, 125);
      ctx.fillText("Press SPACE to start", WIDTH / 2, 145);

      // Snake color previews
      const boxHeight = 40;
      const spacingY = 70;
      const perRow = 4;
      const startY = 190;

      SNAKE_COLORS.forEach((scheme, index) => {
        const row = Math.floor(index / perRow);
        const col = index % perRow;

        const xBase = WIDTH / 2 - 220 + col * 130;
        const yBase = startY + row * spacingY;

        for (let i = 0; i < 3; i++) {
          const rectX = xBase + i * 18;
          const rectY = yBase;
          const color = i === 0 ? scheme.head : scheme.body;
          ctx.fillStyle = rgb(color);
          ctx.fillRect(rectX, rectY, 16, boxHeight);
        }

        if (index === selectedColorIndex) {
          ctx.strokeStyle = rgb(COLORS.WHITE);
          ctx.lineWidth = 3;
          ctx.strokeRect(xBase - 6, yBase - 6, 60, boxHeight + 12);
        }

        ctx.font = "13px sans-serif";
        ctx.fillStyle = rgb(COLORS.WHITE);
        ctx.textAlign = "left";
        ctx.fillText(scheme.name, xBase - 10, yBase + boxHeight + 18);
      });

      // Difficulty selection
      const diffY = HEIGHT - 80;
      ctx.font = "20px sans-serif";
      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.textAlign = "center";
      ctx.fillText("Difficulty:", WIDTH / 2, diffY - 30);

      DIFFICULTIES.forEach((d, i) => {
        const x = WIDTH / 2 - 120 + i * 120;
        
        if (i === selectedDifficultyIndex) {
          ctx.fillStyle = rgb(d.color);
          ctx.font = "bold 22px sans-serif";
        } else {
          ctx.fillStyle = rgb(COLORS.GRAY);
          ctx.font = "20px sans-serif";
        }
        ctx.fillText(d.name, x, diffY);

        ctx.font = "12px sans-serif";
        ctx.fillStyle = rgb(COLORS.GRAY);
        ctx.fillText(d.description, x, diffY + 18);
      });
    }

    function drawGame() {
      clearCanvas();

      // Grid
      ctx.strokeStyle = rgb(COLORS.GRAY);
      ctx.lineWidth = 1;
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }

      // Snake
      const colorScheme = SNAKE_COLORS[selectedColorIndex];
      snake.forEach((seg, i) => {
        const isHead = i === 0;
        ctx.fillStyle = isHead ? rgb(colorScheme.head) : rgb(colorScheme.body);
        ctx.fillRect(seg.x * CELL_SIZE, seg.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      });

      // Powerup/food
      if (powerupPos) {
        ctx.fillStyle = getPowerupColor();
        ctx.fillRect(
          powerupPos.x * CELL_SIZE,
          powerupPos.y * CELL_SIZE,
          CELL_SIZE,
          CELL_SIZE
        );
      }

      // Score
      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 10, HEIGHT - 20);

      // Difficulty display
      ctx.font = "16px sans-serif";
      ctx.fillText("Mode: " + DIFFICULTIES[selectedDifficultyIndex].name, 150, HEIGHT - 20);

      // Speed message
      if (speedBoostEndTime > 0) {
        const msg = currentSpeed > baseSpeed ? "SPEED BOOST!" : "SLOWED DOWN!";
        const color = currentSpeed > baseSpeed ? COLORS.PURPLE : COLORS.YELLOW;
        ctx.fillStyle = rgb(color);
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(msg, WIDTH / 2, 25);
      }

      // Music status
      if (musicLoaded) {
        ctx.fillStyle = rgb(COLORS.WHITE);
        ctx.font = "14px sans-serif";
        ctx.textAlign = "right";
        const text = bgMusic && !bgMusic.paused ? "Music: ON (M)" : "Music: OFF (M)";
        ctx.fillText(text, WIDTH - 10, HEIGHT - 20);
      }

      // Game over overlay
      if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        ctx.fillStyle = rgb(COLORS.RED);
        ctx.font = "bold 48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER!", WIDTH / 2, HEIGHT / 2 - 20);

        ctx.fillStyle = rgb(COLORS.WHITE);
        ctx.font = "24px sans-serif";
        ctx.fillText("Final Score: " + score, WIDTH / 2, HEIGHT / 2 + 20);
        
        ctx.font = "18px sans-serif";
        ctx.fillText("Press SPACE to restart", WIDTH / 2, HEIGHT / 2 + 55);
      }
    }

    function draw() {
      if (inSelectionScreen) {
        drawSelectionScreen();
      } else if (inCountdown) {
        drawCountdown();
      } else {
        drawGame();
      }
    }

    // ==== MAIN LOOP ====
    function loop(timestamp) {
      if (!lastStepTime) lastStepTime = timestamp;

      // Update countdown if active
      if (inCountdown) {
        updateCountdown(timestamp);
      }

      const deltaSec = (timestamp - lastStepTime) / 1000;
      const stepInterval = 1 / currentSpeed;

      if (!inSelectionScreen && !gameOver && !inCountdown && deltaSec >= stepInterval) {
        updateGame();
        lastStepTime = timestamp;
      }

      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
