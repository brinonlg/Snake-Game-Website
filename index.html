<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snake Game</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #b39dff 0%, #7c4dff 40%, #4b2bb3 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 24px;
      color: #111;
    }

    /* White card that holds everything */
    #game-container {
      display: flex;
      gap: 30px;
      align-items: flex-start;
      padding: 24px 28px;
      background: #ffffff;
      border-radius: 18px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.7);
    }

    #canvas-section {
      text-align: center;
    }

    canvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #444;
      background: #000;
    }

    #info {
      margin-top: 12px;
      font-size: 14px;
      color: #444;
      line-height: 1.5;
    }

    /* Shared style for the side cards (legend + controls) */
    .side-card {
      background: #fdfdfd;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      padding: 16px 18px;
      width: 230px;
      color: #111;
      font-size: 14px;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
    }

    .side-card h2 {
      margin: 0 0 12px 0;
      font-size: 18px;
      color: #222;
      border-bottom: 1px solid #ddd;
      padding-bottom: 8px;
    }

    /* Power-up legend-specific styles */
    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      font-size: 13px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 10px;
      border: 1px solid #666;
      flex-shrink: 0;
    }

    .legend-text {
      line-height: 1.3;
    }

    .legend-title {
      font-weight: bold;
      color: #000;
    }

    .legend-desc {
      color: #555;
      font-size: 12px;
    }

    .section-divider {
      border-top: 1px solid #ddd;
      margin: 14px 0;
    }

    /* Controls card styles */
    #controls {
      width: 210px;
    }

    .control-row {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      font-size: 13px;
    }

    .key-box {
      width: 26px;
      height: 26px;
      border-radius: 4px;
      border: 1px solid #666;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      margin-right: 10px;
      background: #f3f3f3;
      box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.7);
    }

    .control-label-main {
      font-weight: 600;
      color: #111;
    }

    .control-label-sub {
      font-size: 12px;
      color: #555;
    }
  </style>
</head>
<body>
  <div id="game-container">

    <!-- LEFT: controls key -->
    <div id="controls" class="side-card">
      <h2>Controls</h2>

      <div class="control-row">
        <div class="key-box">W</div>
        <div>
          <div class="control-label-main">Move Up</div>
          <div class="control-label-sub">Hold to keep going upward</div>
        </div>
      </div>

      <div class="control-row">
        <div class="key-box">S</div>
        <div>
          <div class="control-label-main">Move Down</div>
          <div class="control-label-sub">Hold to keep going downward</div>
        </div>
      </div>

      <div class="control-row">
        <div class="key-box">A</div>
        <div>
          <div class="control-label-main">Move Left</div>
          <div class="control-label-sub">Turn the snake left</div>
        </div>
      </div>

      <div class="control-row">
        <div class="key-box">D</div>
        <div>
          <div class="control-label-main">Move Right</div>
          <div class="control-label-sub">Turn the snake right</div>
        </div>
      </div>

      <div class="section-divider"></div>

      <div class="control-row">
        <div class="key-box">C</div>
        <div>
          <div class="control-label-main">Continue</div>
          <div class="control-label-sub">Reset snake to center, keep score</div>
        </div>
      </div>

      <div class="control-row">
        <div class="key-box">M</div>
        <div>
          <div class="control-label-main">Toggle Music</div>
        </div>
      </div>

      <div class="control-row">
        <div class="key-box">R</div>
        <div>
          <div class="control-label-main">New Selection</div>
          <div class="control-label-sub">Return to avatar + difficulty screen</div>
        </div>
      </div>

      <div class="control-row">
        <div class="key-box">‚ê£</div>
        <div>
          <div class="control-label-main">Start / Replay</div>
          <div class="control-label-sub">Start game or replay after Game Over</div>
        </div>
      </div>
    </div>

    <!-- CENTER: game canvas -->
    <div id="canvas-section">
      <canvas id="game" width="510" height="560"></canvas>
      <div id="info">
        <div>Selection: A/D = color, W/S = difficulty, SPACE = start</div>
        <div>In game: W/A/S/D to move, C = continue from center, M = music, SPACE after Game Over = restart, R = new selection</div>
      </div>
    </div>

    <!-- RIGHT: power-up legend -->
    <div id="legend" class="side-card">
      <h2>Power-Ups</h2>

      <div class="legend-item">
        <div class="legend-color" style="background: #FF0000;"></div>
        <div class="legend-text">
          <div class="legend-title">Red - Food</div>
          <div class="legend-desc">Grow by 1 segment</div>
        </div>
      </div>

      <div class="legend-item">
        <div class="legend-color" style="background: #800080;"></div>
        <div class="legend-text">
          <div class="legend-title">Purple - Speed Up</div>
          <div class="legend-desc">+0.2 speed for 5 sec</div>
        </div>
      </div>

      <div class="legend-item">
        <div class="legend-color" style="background: #90EE90;"></div>
        <div class="legend-text">
          <div class="legend-title">Green - Teleport</div>
          <div class="legend-desc">Random teleport</div>
        </div>
      </div>

      <div class="legend-item">
        <div class="legend-color" style="background: #FFFF00;"></div>
        <div class="legend-text">
          <div class="legend-title">Yellow - Slow Down</div>
          <div class="legend-desc">-0.2 speed for 5 sec</div>
        </div>
      </div>

      <div class="legend-item">
        <div class="legend-color" style="background: #0000FF;"></div>
        <div class="legend-text">
          <div class="legend-title">Blue - Double Growth</div>
          <div class="legend-desc">Grow by 2 segments</div>
        </div>
      </div>

      <div class="section-divider"></div>

      <h2 style="margin-top: 8px;">Difficulty</h2>
      <div style="font-size: 13px; line-height: 1.6; color: #333;">
        <div style="margin-bottom: 8px;">
          <strong style="color: #4CAF50;">Easy:</strong> Only red food
        </div>
        <div style="margin-bottom: 8px;">
          <strong style="color: #FFA500;">Medium:</strong> All except green
        </div>
        <div style="margin-bottom: 2px;">
          <strong style="color: #F44336;">Hard:</strong> All power-ups
        </div>
      </div>
    </div>
  </div>

  <script>
    // ==== CONFIGURATION ====
    const GRID_SIZE = 17;
    const CELL_SIZE = 30;
    const WIDTH = GRID_SIZE * CELL_SIZE;
    const HEIGHT = GRID_SIZE * CELL_SIZE + 50;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const Direction = {
      UP:    { x:  0, y: -1 },
      DOWN:  { x:  0, y:  1 },
      LEFT:  { x: -1, y:  0 },
      RIGHT: { x:  1, y:  0 }
    };

    const POWERUP_TYPES = {
      FOOD: "FOOD",
      SPEED_UP: "SPEED_UP",
      TELEPORT: "TELEPORT",
      SLOW_DOWN: "SLOW_DOWN",
      DOUBLE_GROWTH: "DOUBLE_GROWTH"
    };

    // Difficulty modes
    const DIFFICULTIES = [
      {
        name: "Easy",
        description: "Only red food",
        id: "EASY",
        color: [144, 238, 144]
      },
      {
        name: "Medium",
        description: "All except green",
        id: "MEDIUM",
        color: [255, 255, 0]
      },
      {
        name: "Hard",
        description: "All power-ups",
        id: "HARD",
        color: [255, 102, 102]
      }
    ];

    // Snake color schemes
    const SNAKE_COLORS = [
      { name: "Classic Green", head: [0, 255, 0], body: [0, 200, 0] },
      { name: "Ocean Blue",   head: [0, 150, 255], body: [0, 100, 200] },
      { name: "Fire Red",     head: [255, 50, 50], body: [200, 0, 0] },
      { name: "Royal Purple", head: [180, 0, 255], body: [120, 0, 180] },
      { name: "Sunset Orange",head: [255, 165, 0], body: [200, 100, 0] },
      { name: "Bubblegum Pink", head: [255, 192, 203], body: [255, 100, 150] },
      { name: "Cyber Cyan",   head: [0, 255, 255], body: [0, 180, 180] },
      { name: "Golden",       head: [255, 215, 0], body: [218, 165, 32] }
    ];

    const COLORS = {
      BLACK: [0, 0, 0],
      WHITE: [255, 255, 255],
      RED: [255, 0, 0],
      GRAY: [50, 50, 50],
      PURPLE: [128, 0, 128],
      YELLOW: [255, 255, 0],
      BLUE: [0, 0, 255],
      LIGHT_GREEN: [144, 238, 144]
    };

    function rgb(arr) {
      return `rgb(${arr[0]}, ${arr[1]}, ${arr[2]})`;
    }

    // ==== GAME STATE ====
    let inSelectionScreen = true;
    let selectedColorIndex = 0;
    let selectedDifficultyIndex = 1; // Start with Medium

    let snake = [];
    let direction = Direction.RIGHT;
    let nextDirection = Direction.RIGHT;

    let currentPowerup = POWERUP_TYPES.FOOD;
    let powerupPos = null;

    let score = 0;
    const baseSpeed = 10;
    let currentSpeed = baseSpeed;
    let speedBoostEndTime = 0;

    let gameOver = false;
    let lastStepTime = 0;
    
    // Countdown state
    let inCountdown = false;
    let countdownNumber = 3;
    let countdownStartTime = 0;
    let countdownScale = 1;

    // Music
    let bgMusic = null;
    let musicLoaded = false;
    let userInteracted = false;
    try {
      bgMusic = new Audio("background_music.mp3");
      bgMusic.loop = true;
      musicLoaded = true;
    } catch (e) {
      musicLoaded = false;
    }

    function toggleMusic() {
      if (!bgMusic || !musicLoaded) return;
      if (bgMusic.paused) {
        bgMusic.play().catch(() => {});
      } else {
        bgMusic.pause();
      }
    }

    // ==== HELPERS ====
    function randomEmptyCell() {
      while (true) {
        const x = Math.floor(Math.random() * GRID_SIZE);
        const y = Math.floor(Math.random() * GRID_SIZE);
        if (!snake.some(seg => seg.x === x && seg.y === y)) {
          return { x, y };
        }
      }
    }

    function spawnItem() {
      powerupPos = randomEmptyCell();
    }

    function spawnNewPowerup() {
      const difficultyId = DIFFICULTIES[selectedDifficultyIndex].id;
      let possible = [];

      if (difficultyId === "EASY") {
        currentPowerup = POWERUP_TYPES.FOOD;
        spawnItem();
        return;
      } else if (difficultyId === "MEDIUM") {
        possible = [
          POWERUP_TYPES.FOOD,
          POWERUP_TYPES.SPEED_UP,
          POWERUP_TYPES.SLOW_DOWN,
          POWERUP_TYPES.DOUBLE_GROWTH
        ];
      } else {
        possible = [
          POWERUP_TYPES.FOOD,
          POWERUP_TYPES.SPEED_UP,
          POWERUP_TYPES.TELEPORT,
          POWERUP_TYPES.SLOW_DOWN,
          POWERUP_TYPES.DOUBLE_GROWTH
        ];
      }

      currentPowerup = possible[Math.floor(Math.random() * possible.length)];
      spawnItem();
    }

    function getPowerupColor() {
      if (currentPowerup === POWERUP_TYPES.FOOD) return rgb(COLORS.RED);
      if (currentPowerup === POWERUP_TYPES.SPEED_UP) return rgb(COLORS.PURPLE);
      if (currentPowerup === POWERUP_TYPES.TELEPORT) return rgb(COLORS.LIGHT_GREEN);
      if (currentPowerup === POWERUP_TYPES.SLOW_DOWN) return rgb(COLORS.YELLOW);
      if (currentPowerup === POWERUP_TYPES.DOUBLE_GROWTH) return rgb(COLORS.BLUE);
      return rgb(COLORS.RED);
    }

    // ==== GAME SETUP ====
    function startCountdown() {
      inSelectionScreen = false;
      inCountdown = true;
      countdownNumber = 3;
      countdownStartTime = performance.now();
      countdownScale = 1;
    }
    
    function startGame() {
      const startX = Math.floor(GRID_SIZE / 2);
      const startY = Math.floor(GRID_SIZE / 2);
      snake = [
        { x: startX, y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];

      direction = Direction.RIGHT;
      nextDirection = Direction.RIGHT;
      score = 0;
      gameOver = false;
      currentSpeed = baseSpeed;
      speedBoostEndTime = 0;

      currentPowerup = POWERUP_TYPES.FOOD;
      spawnItem();

      inCountdown = false;
      lastStepTime = performance.now();

      if (bgMusic && musicLoaded && userInteracted) {
        bgMusic.play().catch(() => {});
        bgMusic.volume = 0.5;
      }
    }

    // NEW: continue with same score, reset snake to center
    function resetSnakeKeepScore() {
      const startX = Math.floor(GRID_SIZE / 2);
      const startY = Math.floor(GRID_SIZE / 2);
      snake = [
        { x: startX, y: startY },
        { x: startX - 1, y: startY },
        { x: startX - 2, y: startY }
      ];

      direction = Direction.RIGHT;
      nextDirection = Direction.RIGHT;
      gameOver = false;
      inCountdown = false;
      inSelectionScreen = false;

      currentSpeed = baseSpeed;
      speedBoostEndTime = 0;

      currentPowerup = POWERUP_TYPES.FOOD;
      spawnItem();

      lastStepTime = performance.now();

      if (bgMusic && musicLoaded && userInteracted) {
        if (bgMusic.paused) {
          bgMusic.play().catch(() => {});
        }
        bgMusic.volume = 0.5;
      }
    }

    function resetToSelectionScreen() {
      inSelectionScreen = true;
      gameOver = false;
      inCountdown = false;
      if (bgMusic && musicLoaded) {
        bgMusic.pause();
      }
    }

    // ==== INPUT ====
    document.addEventListener("keydown", (e) => {
      userInteracted = true;

      // Selection screen controls (WASD)
      if (inSelectionScreen) {
        if (e.key === "a" || e.key === "A") {
          selectedColorIndex =
            (selectedColorIndex - 1 + SNAKE_COLORS.length) % SNAKE_COLORS.length;
        } else if (e.key === "d" || e.key === "D") {
          selectedColorIndex =
            (selectedColorIndex + 1) % SNAKE_COLORS.length;
        } else if (e.key === "w" || e.key === "W") {
          selectedDifficultyIndex =
            (selectedDifficultyIndex - 1 + DIFFICULTIES.length) % DIFFICULTIES.length;
        } else if (e.key === "s" || e.key === "S") {
          selectedDifficultyIndex =
            (selectedDifficultyIndex + 1) % DIFFICULTIES.length;
        } else if (e.key === " " || e.code === "Space") {
          e.preventDefault();
          startCountdown();
        }
        return;
      }

      // In-game controls (WASD)
      if (e.key === "w" || e.key === "W") {
        if (direction !== Direction.DOWN) nextDirection = Direction.UP;
      } else if (e.key === "s" || e.key === "S") {
        if (direction !== Direction.UP) nextDirection = Direction.DOWN;
      } else if (e.key === "a" || e.key === "A") {
        if (direction !== Direction.RIGHT) nextDirection = Direction.LEFT;
      } else if (e.key === "d" || e.key === "D") {
        if (direction !== Direction.LEFT) nextDirection = Direction.RIGHT;
      } else if (e.key === "m" || e.key === "M") {
        toggleMusic();
      } else if (e.key === "r" || e.key === "R") {
        resetToSelectionScreen();
      } else if (e.key === "c" || e.key === "C") {
        // continue from center with same score
        e.preventDefault();
        resetSnakeKeepScore();
      } else if ((e.key === " " || e.code === "Space") && gameOver) {
        e.preventDefault();
        startCountdown();
      }
    });

    // ==== UPDATE ====
    function updateCountdown(timestamp) {
      const elapsed = timestamp - countdownStartTime;
      const numberDuration = 1000; // 1 second each
      
      const numberIndex = Math.floor(elapsed / numberDuration);
      
      if (numberIndex >= 3) {
        startGame();
        return;
      }
      
      countdownNumber = 3 - numberIndex;
      const progress = (elapsed % numberDuration) / numberDuration;
      countdownScale = 3.0 - (progress * 2.0);
    }
    
    function updateGame() {
      if (gameOver || inSelectionScreen || inCountdown) return;

      const nowSec = performance.now() / 1000;
      if (speedBoostEndTime > 0 && nowSec >= speedBoostEndTime) {
        currentSpeed = baseSpeed;
        speedBoostEndTime = 0;
      }

      direction = nextDirection;

      const head = snake[0];
      const newHead = {
        x: head.x + direction.x,
        y: head.y + direction.y
      };

      // Walls
      if (
        newHead.x < 0 || newHead.x >= GRID_SIZE ||
        newHead.y < 0 || newHead.y >= GRID_SIZE
      ) {
        gameOver = true;
        if (bgMusic && musicLoaded) bgMusic.pause();
        return;
      }

      // Self collision
      if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        gameOver = true;
        if (bgMusic && musicLoaded) bgMusic.pause();
        return;
      }

      snake.unshift(newHead);

      // Eat powerup?
      if (powerupPos && newHead.x === powerupPos.x && newHead.y === powerupPos.y) {
        score += 1;

        if (currentPowerup === POWERUP_TYPES.FOOD) {
          // just grow
        } else if (currentPowerup === POWERUP_TYPES.SPEED_UP) {
          currentSpeed = baseSpeed + 2;
          speedBoostEndTime = nowSec + 5;
        } else if (currentPowerup === POWERUP_TYPES.SLOW_DOWN) {
          currentSpeed = Math.max(5, baseSpeed - 2);
          speedBoostEndTime = nowSec + 5;
        } else if (currentPowerup === POWERUP_TYPES.TELEPORT) {
          const newPos = randomEmptyCell();
          snake[0] = newPos;
        } else if (currentPowerup === POWERUP_TYPES.DOUBLE_GROWTH) {
          if (snake.length > 1) {
            const tail = snake[snake.length - 1];
            snake.push({ x: tail.x, y: tail.y });
          }
        }

        spawnNewPowerup();
      } else {
        snake.pop();
      }
    }

    // ==== DRAW ====
    function clearCanvas() {
      ctx.fillStyle = rgb(COLORS.BLACK);
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }
    
    function drawCountdown() {
      clearCanvas();
      
      // Grid faintly in background
      ctx.strokeStyle = rgb(COLORS.GRAY);
      ctx.lineWidth = 1;
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }
      
      ctx.save();
      ctx.translate(WIDTH / 2, (HEIGHT - 50) / 2);
      ctx.scale(countdownScale, countdownScale);
      
      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.font = "bold 120px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(countdownNumber, 0, 0);
      
      ctx.restore();
    }

    function drawSelectionScreen() {
      clearCanvas();

      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.font = "bold 32px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("SELECT YOUR SNAKE", WIDTH / 2, 70);

      ctx.font = "16px sans-serif";
      ctx.fillStyle = "rgba(220,220,220,0.9)";
      ctx.fillText("Use A/D keys to choose color", WIDTH / 2, 100);
      ctx.fillText("Use W/S keys to choose difficulty", WIDTH / 2, 122);
      ctx.fillText("Press SPACE to start", WIDTH / 2, 144);

      const boxHeight = 40;
      const spacingY = 70;
      const perRow = 4;
      const startY = 190;

      SNAKE_COLORS.forEach((scheme, index) => {
        const row = Math.floor(index / perRow);
        const col = index % perRow;

        const xBase = WIDTH / 2 - 220 + col * 130;
        const yBase = startY + row * spacingY;

        for (let i = 0; i < 3; i++) {
          const rectX = xBase + i * 18;
          const rectY = yBase;
          const color = i === 0 ? scheme.head : scheme.body;
          ctx.fillStyle = rgb(color);
          ctx.fillRect(rectX, rectY, 16, boxHeight);
        }

        if (index === selectedColorIndex) {
          ctx.strokeStyle = rgb(COLORS.WHITE);
          ctx.lineWidth = 3;
          ctx.strokeRect(xBase - 6, yBase - 6, 60, boxHeight + 12);
        }

        ctx.font = "13px sans-serif";
        ctx.fillStyle = rgb(COLORS.WHITE);
        ctx.textAlign = "left";
        ctx.fillText(scheme.name, xBase - 10, yBase + boxHeight + 18);
      });

      const diffY = HEIGHT - 80;
      ctx.font = "20px sans-serif";
      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.textAlign = "center";
      ctx.fillText("Difficulty:", WIDTH / 2, diffY - 30);

      DIFFICULTIES.forEach((d, i) => {
        const x = WIDTH / 2 - 120 + i * 120;
        
        if (i === selectedDifficultyIndex) {
          ctx.fillStyle = rgb(d.color);
          ctx.font = "bold 22px sans-serif";
        } else {
          ctx.fillStyle = "rgba(160,160,160,0.8)";
          ctx.font = "20px sans-serif";
        }
        ctx.fillText(d.name, x, diffY);

        ctx.font = "12px sans-serif";
        ctx.fillStyle = "rgba(180,180,180,0.8)";
        ctx.fillText(d.description, x, diffY + 18);
      });
    }

    function drawGame() {
      clearCanvas();

      // Grid
      ctx.strokeStyle = rgb(COLORS.GRAY);
      ctx.lineWidth = 1;
      for (let x = 0; x < GRID_SIZE; x++) {
        for (let y = 0; y < GRID_SIZE; y++) {
          ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }

      const colorScheme = SNAKE_COLORS[selectedColorIndex];
      snake.forEach((seg, i) => {
        const isHead = i === 0;
        ctx.fillStyle = isHead ? rgb(colorScheme.head) : rgb(colorScheme.body);
        ctx.fillRect(seg.x * CELL_SIZE, seg.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
      });

      if (powerupPos) {
        ctx.fillStyle = getPowerupColor();
        ctx.fillRect(
          powerupPos.x * CELL_SIZE,
          powerupPos.y * CELL_SIZE,
          CELL_SIZE,
          CELL_SIZE
        );
      }

      ctx.fillStyle = rgb(COLORS.WHITE);
      ctx.font = "20px sans-serif";
      ctx.textAlign = "left";
      ctx.fillText("Score: " + score, 10, HEIGHT - 20);

      ctx.font = "16px sans-serif";
      ctx.fillText("Mode: " + DIFFICULTIES[selectedDifficultyIndex].name, 150, HEIGHT - 20);

      if (speedBoostEndTime > 0) {
        const msg = currentSpeed > baseSpeed ? "SPEED BOOST!" : "SLOWED DOWN!";
        const color = currentSpeed > baseSpeed ? COLORS.PURPLE : COLORS.YELLOW;
        ctx.fillStyle = rgb(color);
        ctx.font = "20px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(msg, WIDTH / 2, 25);
      }

      if (musicLoaded) {
        ctx.fillStyle = rgb(COLORS.WHITE);
        ctx.font = "14px sans-serif";
        ctx.textAlign = "right";
        const text = bgMusic && !bgMusic.paused ? "Music: ON (M)" : "Music: OFF (M)";
        ctx.fillText(text, WIDTH - 10, HEIGHT - 20);
      }

      if (gameOver) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        ctx.fillStyle = rgb(COLORS.RED);
        ctx.font = "bold 48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER!", WIDTH / 2, HEIGHT / 2 - 20);

        ctx.fillStyle = rgb(COLORS.WHITE);
        ctx.font = "24px sans-serif";
        ctx.fillText("Final Score: " + score, WIDTH / 2, HEIGHT / 2 + 20);
        
        ctx.font = "18px sans-serif";
        ctx.fillText("Press C to continue from center", WIDTH / 2, HEIGHT / 2 + 50);
        ctx.fillText("Press SPACE to play again", WIDTH / 2, HEIGHT / 2 + 75);
        ctx.fillText("Press R for new selection", WIDTH / 2, HEIGHT / 2 + 100);
      }
    }

    function draw() {
      if (inSelectionScreen) {
        drawSelectionScreen();
      } else if (inCountdown) {
        drawCountdown();
      } else {
        drawGame();
      }
    }

    // ==== MAIN LOOP ====
    function loop(timestamp) {
      if (!lastStepTime) lastStepTime = timestamp;

      if (inCountdown) {
        updateCountdown(timestamp);
      }

      const deltaSec = (timestamp - lastStepTime) / 1000;
      const stepInterval = 1 / currentSpeed;

      if (!inSelectionScreen && !gameOver && !inCountdown && deltaSec >= stepInterval) {
        updateGame();
        lastStepTime = timestamp;
      }

      draw();
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
